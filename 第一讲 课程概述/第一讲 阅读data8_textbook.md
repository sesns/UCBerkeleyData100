# 什么是数据科学

    数据科学是关于通过探索，预测和推论从大量且多样的数据中得出有用的结论

    探索：发现信息中的模式

    预测：使用已知信息去作出有根据的猜测

    推论：包括量化确认度：我们的预测有多精确、我们在数据中发现的模式是否也会出现在新观察中？

    工具

- 对于探索，有描述性统计学、可视化

- 对于预测，有机器学习与优化

- 对于推论，有统计测试和模型

## 运算工具

    本书采用python3及其一些数据可视化工具

## 统计技术

    统计的最重要贡献之一是描述观察和结论之间关系的一致且精确的词汇。

    本文涉及到以下问题：测试假设，估计置信度和预测未知数量等

# 因果和实验

## 概念

实验和结果之间的任何关系被称为**关联**。如果实验导致结果发生，那么这个关联是**因果关系**。

## 实验组和对照组

科学家使用比较来确定实验与结果之间的关联，即实验和结果之间存在联系。他们比较了一组接受实验的个体（**实验组**）的结果，和一组没有接受实验的个体的结果（**对照组**）。

## 混淆

在一项观察研究中，如果实验组和对照组在实验以外的方面有所不同，则很难对因果关系作出结论。 两组之间在**实验以外**的根本区别被称为**混淆因素**，因为当你试图得出结论时，它可能会混淆你。

## 随机化

**避免混淆**的一个很好的方法是，将个体随机分配到实验和对照组，然后将实验给予分配到实验组的人。随机化使两组除了实验之外都相似。如果你能够将个体随机分为实验组和对照组，则你正在进行一项**随机对照试验**（RCT）

有时候，人们在实验中的反应会受到他们知道他们在哪个群体的影响。所以你可能希望进行**盲法实验**，其中个体不知道他们是在实验组还是对照组。为了使它有效，你必须把安慰剂给控制组，这是一种和实验看起来完全一样的东西，但实际上没有效果。

在某些情况下，即使目标是调查因果关系，也不可能进行随机对照实验。

随机化的优点是

- 它使我们能够以数学方式，计算随机化产生实验和对照组的可能性。

- 它使我们能够对实验组和对照组之间的差异作出**精确的数学表述**。这反过来帮助我们对实验是否有效作出正确的结论。

## 因果关系

因果关系的建立往往分两个阶段进行。首先，观察一个关联。接下来，更仔细的分析是否存在因果关系。

## 总结

在本课程中，你将学习如何进行和分析你自己的随机实验。这将涉及比本节更多的细节。

**目前，只需关注主要思想：尝试建立因果关系，如果可能，进行随机对照实验。**

注意：如果你正在进行一项观察研究，你可能能够建立联系而不是因果关系。在根据观察研究得出因果关系的结论之前，要非常小心混淆因素。

    

# Python编程

## 运算符

| 表达式类型 | 运算符     | 示例         | 值       |
|:-----:|:-------:|:----------:|:-------:|
| 加法    | `+`     | `2 + 3`    | 5       |
| 减法    | `-`     | `2 - 3`    | -1      |
| 乘法    | `*`     | `2 * 3`    | 6       |
| 除法    | `/`     | `7 / 3`    | 2.66667 |
| 取余    | `%`     | `7 % 3`    | 1       |
| 指数    | `**`    | `2 ** 0.5` | 1.41421 |
| 括号    | （）[] {} |            |         |

## 数值

整数在 Python 语言中称为`int`值。 它们只能表示没有小数部分的整数（负数，零或正数）

实数在 Python 语言中被称为`float`值（或浮点值）。 他们可以表示全部或部分数字，但有一些限制。

当一个`float`值和一个`int`值，通过算术运算符组合在一起时，结果总是一个`float`值。

在大多数情况下，两个整数的组合形成另一个整数，但任何数字（`int`或`float`）除以另一个将是一个`float`值。

浮点数只能表示任何数字的 15 或 16 位有效数字；剩下的精度就会丢失。 如果一个计算的结果是一个非常大的数字，那么它被表示为无限大。 如果结果是非常小的数字，则表示为零。

## 名称

名称通过赋值语句在 Python 中得到一个值。 在赋值中，名称后面是`=`，再后面是任何表达式。 `=`右边的表达式的值被赋给名称。

名称必须以字母开头，但可以包含字母和数字。 名称不能包含空格；相反，通常使用下划线字符`_`来替换每个空格

## 函数

一些函数默认是可用的，比如`abs`和`round`，但是大部分内置于 Python 语言的函数都存储在一个称为模块的函数集合中。**导入语句用于访问模块**，如`math`或`operator`。

```py
import math
import operator
math.sqrt(operator.add(4, 5))
3.0
```

## 类型

每个值都有一个类型，内建的`type`函数返回任何表达式的结果的类型

## 字符串

单引号和双引号都可以用来创建字符串：`'hi'`和`"hi"`是相同的表达式。 双引号通常是首选，因为它们允许在字符串中包含单引号。

字符串也有一些方法，例如replace、upper

```py
"loud".upper()
'LOUD'
'hitchhiker'.replace('hi', 'ma')
'matchmaker'
s = "train"
t = s.replace('t', 'ing')
u = t.replace('in', 'de')
u
'degrade'
```

## 比较运算符

一个表达式可以包含多个比较

| 比较   | 运算符  | True 示例  | False 示例 |
| ---- | ---- | -------- | -------- |
| 小于   | `<`  | `2 < 3`  | `<`      |
| 大于   | `>`  | `3 > 2`  | `>`      |
| 小于等于 | `<=` | `<=`     | `3 <= 2` |
| 大于等于 | `>=` | `>=`     | `2 >= 3` |
| 等于   | `==` | `==`     | `3 == 2` |
| 不等于  | `!=` | `3 != 2` | `!=`     |

## 集合

Python 中有很多种类的集合，我们在这门课中主要使用数组。

在几个值上调用`make_array`函数，将它们放到一个数组中，这是一种顺序集合。

集合允许我们使用单个名称，将多个值传递给一个函数。 例如，`sum`函数计算集合中所有值的和，`len`函数计算其长度。

## 数组

`make_array`函数可以用来创建数值的数组。

数组也可以包含字符串或其他类型的值，但是**单个数组只能包含单一类型的数据。**

```py
english_parts_of_speech = make_array("noun", "pronoun", "verb", "adverb", "adjective", "conjunction", "preposition", "interjection")
```

数组可以用在算术表达式中来计算其内容。 当数组与单个数组合时，该数与数组的每个元素组合。

```py
(9/5) * highs + 32
array([ 56.48  ,  57.8966,  58.253 ,  59.2952])
```

数组也有方法，这些方法是操作数组值的函数。

```py
highs.size
4
highs.sum()
57.736000000000004
highs.mean()
14.434000000000001
```

## 数组上的函数

`numpy`包，在程序中缩写为`np`，为 Python 程序员提供了创建和操作数组的，方便而强大的函数。

```py
import numpy as np
```

每个这些函数接受数组作为参数，并返回单个值。

| 函数                 | 描述                    |
| ------------------ | --------------------- |
| `np.prod`          | 将所有元素相乘               |
| `np.sum`           | 将所有元素相加               |
| `np.all`           | 测试是否所有元素是真值 （非零数值是真值） |
| `np.any`           | 测试是否任意元素是真值（非零数值是真值）  |
| `np.count_nonzero` | 计算非零元素的数量             |

每个这些函数接受字符串数组作为参数，并返回数组。

| 函数                  | 描述                    |
| ------------------- | --------------------- |
| `np.char.lower`     | 将每个元素变成小写             |
| `np.char.upper`     | 将每个元素变成大写             |
| `np.char.strip`     | 移除每个元素开头或末尾的空格        |
| `np.char.isalpha`   | 每个元素是否只含有字母（没有数字或者符号） |
| `np.char.isnumeric` | 每个元素是否只含有数字（没有字母）     |

每个这些函数接受字符串数组和一个搜索字符串。

| 函数                 | 描述                    |
| ------------------ | --------------------- |
| np.char.count      | 在数组的元素中，计算搜索字符串的出现次数  |
| np.char.find       | 在每个元素中，搜索字符串的首次出现位置   |
| np.char.rfind      | 在每个元素中，搜索字符串的最后一次出现位置 |
| np.char.startswith | 每个字符串是否以搜索字符串起始       |

## 范围

范围是一个数组，按照递增或递减的顺序排列，每个元素按照一定的间隔分开。

范围使用`np.arange`函数来定义，该函数接受一个，两个或三个参数：起始值，终止值和“步长”。

如果将一个参数传递给`np.arange`，那么它将成为终止值，其中`start = 0`，`step = 1`。 两个参数提供了起始值和终止值，`step = 1`。 三个参数明确地提供了起始值，终止值和步长。

**范围始终包含其`start`值，但不包括其`end`值。 它按照`step`计数，并在到达`end`之前停止。**

```py
np.arange(5)
array([0, 1, 2, 3, 4])

np.arange(3, 9)
array([3, 4, 5, 6, 7, 8])

np.arange(3, 30, 5)
array([ 3,  8, 13, 18, 23, 28])


np.arange(1.5, -2, -0.5)
array([ 1.5,  1. ,  0.5,  0. , -0.5, -1. , -1.5])
```

# 表格

## 模块导入

```py
from datascience import *
```

## 创建表格

创建一个新的空表格

```py
Table()
```

`with_columns`方法将新列添加到表中

```py
Table().with_columns('XXX', make_array(8, 34, 5))

Table().with_columns(
    'Number of petals', make_array(8, 34, 5),
    'Name', make_array('lotus', 'sunflower', 'rose'))

flowers = Table().with_columns(
    'Number of petals', make_array(8, 34, 5),
    'Name', make_array('lotus', 'sunflower', 'rose')
)

flowers.with_columns(
    'Color', make_array('pink', 'yellow', 'red')
)
```

通过使用`Table`的`read_table`方法读入CSV文件创建表格

```python
minard = Table.read_table('minard.csv')
minard
```

## 列的选取

`show`展示行，允许我们指定行数，缺省值（没有指定）是表的所有行。

```py
nba_salaries.show(3)
```

通过使用`relabeled`修改列标签。这会创建新的表格，并保留原表格不变。 

```python
minard.relabeled('City', 'City Name')
```

查看表格中列的数量、行的数量

```py
minard.num_columns
5
minard.num_rows
8
```

访问表格中某一列数组，参数为列名或列下标

列下标从0开始

```py
minard.column('Survivors')
array([145000, 140000, 127100, 100000,  55000,  24000,  20000,  12000])

minard.column(4)
array([145000, 140000, 127100, 100000,  55000,  24000,  20000,  12000])
```

访问列的某一条目

```py
minard.column(4).item(0)
145000
minard.column(4).item(5)
24000
```

用选项`PercentFormatter`调用`set_format`方法，使得列中的比例显示为百分比

```py
minard.set_format('Percent Surviving', PercentFormatter)
```

`select`方法创建一个新表，仅仅包含指定的列

```py
minard.select('Longitude', 'Latitude')
minard.select(0, 1)
```

另一种创建新表，包含列集合的方式，是`drop`你不想要的列。

```py
minard.drop('Longitude', 'Latitude', 'Direction')
```

## 行的选取

take()方法指定行，可以传入单个索引，也可以传入一系列索引

```py
nba.take(0)
nba.take(np.arange(3, 6)) //选取第4、5、6行
```

where选取具有指定特征的行，特征由are指定

`where`的第一个参数是列标签，`where`的第二个参数是用于指定特征的方式。

它的输出是一个表格，列与原始表格相同，但只有特征出现的行。

通过重复使用`where`，你可以访问具有多个指定特征的行

```py
original_table_name.where(column_label_string, are.condition)

nba.where('POSITION', 'PG').where('SALARY', are.above(15))
```

这里有一些谓词，你可能会觉得有用。 请注意，`x`和`y`是数字，`STRING`是一个字符串，`Z`是数字或字符串；你必须指定这些，取决于你想要的特征

| 谓词                              | 描述              |
| ------------------------------- | --------------- |
| `are.equal_to(Z)`               | 等于`Z`           |
| `are.above(x)`                  | 大于`x`           |
| `are.above_or_equal_to(x)`      | 大于等于`x`         |
| `are.below(x)`                  | 小于`x`           |
| `are.below_or_equal_to(x)`      | 小于等于`x`         |
| `are.between(x, y)`             | 大于等于`x`，小于`y`   |
| `are.strictly_between(x, y)`    | 大于`x`，小于`y`     |
| `are.between_or_equal_to(x, y)` | 大于等于`x`，小于等于`y` |
| `are.containing(S)`             | 包含字符串`S`        |

| 谓词                    | 描述     |
| --------------------- | ------ |
| `are.not_equal_to(Z)` | 不等于`Z` |
| `are.not_above(x)`    | 不大于`x` |

## 对行排序

`sort`的参数是列标签或索引，默认升序

参数descending=True表示降序

```py
nba_salaries.sort('PLAYER')
nba.sort('SALARY', descending=True)
```

# 可视化

定量：拥有数值的变量，也称数值变量

## 散点图

散点图展示两个数值变量之间的关系

`Table`的`scatter`方法绘制一个散点图，由表格的每一行组成。它的第一个参数是要在横轴上绘制的列标签，第二个参数是纵轴上的列标签。

```py
actors.scatter('Number of Movies', 'Total Gross')


no_outlier = actors.where('Number of Movies', are.above(10))
no_outlier.scatter('Number of Movies', 'Average per Movie')
```

![](https://cdn.jsdelivr.net/gh/sesns/picgo_bed/Snipaste_2023-01-19_21-10-27.png)

## 线形图

线形图是最常见的可视化图形之一，通常用于研究时序型的趋势和模式。

`Table`的`plot`方法产生线形图。 它的两个参数与散点图相同：首先是横轴上的列，然后是纵轴上的列

```python
century_21.plot('Year', 'Number of Movies')
```

![](https://cdn.jsdelivr.net/gh/sesns/picgo_bed/Snipaste_2023-01-19_21-14-05.png)

## 分布表

 分布表，列包括分布变量、每个变量的频率

| Flavor     | Number of Cartons |
| ---------- | ----------------- |
| Chocolate  | 16                |
| Strawberry | 5                 |
| Vanilla    | 9                 |

分类变量“口味”的值是巧克力，草莓和香草。 表格显示了每种口味的纸盒数量。



如何生成分布表？`Table`的`group`方法为我们计算分布变量不同的值出现在表中的频率，生成分布表

```py
movies_and_studios.group('Studio')
```

## 条形图

分布表，列包括分布变量、每个变量的频率

| Flavor     | Number of Cartons |
| ---------- | ----------------- |
| Chocolate  | 16                |
| Strawberry | 5                 |
| Vanilla    | 9                 |

分类变量“口味”的值是巧克力，草莓和香草。 表格显示了每种口味的纸盒数量。

条形图是可视化类别分布的熟悉方式。 它为每个类别显示一个条形。 条形的间隔相等，宽度相同。 每个条形的长度与相应类别的频率成正比。

我们使用横条绘制条形图，因为这样更容易标注条形图。 所以`Table`的方法称为`barh`。 它有两个参数：第一个是类别的列标签，第二个是频率的列标签。

![](https://cdn.jsdelivr.net/gh/sesns/picgo_bed/Snipaste_2023-01-19_21-17-37.png)

除了纯粹的视觉差异之外，条形图和我们在前面章节中看到的两个图表之间还有一个重要的区别。 它们是散点图和线图，两者都显示两个数值变量 - 两个轴上的变量都是数值型的。 相比之下，条形图的一个轴上是类别，在另一个轴上具有数值型频率，这对图表有影响。

## 频率分布直方图

在直角坐标系中，用横轴表示随机变量的取值，横轴上的每个小区间对应一个组的组距，作为小矩形的底边；纵轴表示频率(组频数/总频数=频率)，并用它作小矩形的高，以这种小矩形构成的一组图称为频率直方图。

在直角坐标系中，用横轴表示随机变量的取值，横轴上的每个小区间对应一个组的组距，作为小矩形的底边；纵轴表示频率密度(频率/组距)，并用它作小矩形的高，以这种小矩形构成的一组图称为频率分布直方图（hist）。

在频率分布直方图中，每个小矩形的面积等于相应桶中数值数量占总数量的百分比。所有小矩形的面积“总计为 1”。

![](https://cdn.jsdelivr.net/gh/sesns/picgo_bed/Snipaste_2023-01-19_21-44-57.png)

![](https://cdn.jsdelivr.net/gh/sesns/picgo_bed/Snipaste_2023-01-19_21-45-17.png)

hist方法生成列中值的直方图。 可选的单位参数用于两个轴上的标签。 直方图显示数值的分布

将横轴划分成了若干个区间，每个区间称为“bin”，也称为桶。`bin`包含左端点的数据，但不包含右端点的数据。我们使用符号`[a, b)`表示从`a`开始并在`b`结束但不包括`b`的桶。

```py
millions.hist('Adjusted Gross', unit="Million Dollars")
```

![](https://cdn.jsdelivr.net/gh/sesns/picgo_bed/Snipaste_2023-01-19_21-27-44.png)

可选参数`bins`可以与`hist`一起使用来指定桶的端点。它必须由一系列数字组成，这些数字以第一个桶的左端开始，以最后一个桶的右端结束。我们首先将桶中的数字设置为`300,400,500`等等，以`2000`结尾。

```py
millions.hist('Adjusted Gross', bins=np.arange(300,2001,100), unit="Million Dollars")
```

可以使用`bin`方法从一个表格中计算出桶中的值的数量，该方法接受列标签或索引，以及可选的序列或桶的数量。

```py
bin_counts = millions.bin('Adjusted Gross', bins=np.arange(300,2001,100))
```

| bin  | Adjusted Gross count |
| ---- | -------------------- |
| 300  | 81                   |
| 400  | 52                   |
| 500  | 28                   |
| 600  | 16                   |
| 700  | 7                    |
| 800  | 5                    |
| 900  | 3                    |
| 1000 | 1                    |
| 1100 | 3                    |
| 1200 | 2                    |
| 1300 | 0                    |
| 1400 | 0                    |
| 1500 | 1                    |
| 1600 | 0                    |
| 1700 | 1                    |
| 1800 | 0                    |
| 1900 | 0                    |
| 2000 | 0                    |

## **直方图使用频率密度作为纵轴的好处**

当桶长度不等时，采用频率作为纵轴的直方图看过去很容易造成误导，无法突出显示数值的密集程度，而使用频率密度作为纵轴的直方图可以突出显示数值的密集程度

![](https://cdn.jsdelivr.net/gh/sesns/picgo_bed/Snipaste_2023-01-19_21-50-33.png)

上图是采用频数作为纵轴的直方图（但是总频数相等，因此其实 这个图和采用频率作为纵轴的直方图差不多）

![](https://cdn.jsdelivr.net/gh/sesns/picgo_bed/Snipaste_2023-01-19_21-54-52.png)

上图是采用频率密度作为纵轴的直方图。虽然范围`[300,400)`和`[400,600)`具有几乎相同的计数，但前者的高度是后者的两倍，因为它只有一半的宽度。 `[300,400)`中的值的密度是`[400,600)`中的密度的两倍。

**频率分布直方图（hist）帮助我们可视化数轴上数据最集中的地方，特别是当桶不均匀的时候。**

## 条形图和直方图的区别

- 条形图为每个类别展示一个数量。 它们通常用于显示**类别变量**的分布。 直方图显示**数值变量**的分布。
- 条形图中的所有条形都具有相同的宽度，相邻的条形之间有相等的间距。 直方图的条形可以具有**不同的宽度**，并且是连续的。
- 条形图中条形的**长度**（或高度，如果垂直绘制）与每个类别的值成正比。 直方图中条形的高度是密度的度量；直方图中的条形的**面积**与桶中的条目数量成正比。

## 重叠的图表

在这一章中，我们学习了如何通过绘制图表来显示数据。 这种可视化的常见用法是比较两个数据集。 在本节中，我们将看到如何叠加绘图，即将它们绘制在单个图形中，拥有同一对坐标轴

为了使重叠有意义，重叠的图必须表示相同的变量并以相同的单位进行测量。

**为了绘制重叠图，可以用相同的方法调用`scatter`，`plot`和`barh`方法。 对于`scatter`和`plot`，一列必须作为所有叠加图的公共横轴。 对于`barh`，一列必须作为一组类别的公共轴。 一般的调用看起来像这样：**

```py
name_of_table.method(column_label_of_common_axis, array_of_labels_of_variables_to_plot)
```

更常见的是，我们首先仅仅选取图表所需的列。之后通过指定共同轴上的变量来调用方法。

```py
name_of_table.method(column_label_of_common_axis)
```

![](https://cdn.jsdelivr.net/gh/sesns/picgo_bed/Snipaste_2023-01-19_22-09-41.png)
![](https://cdn.jsdelivr.net/gh/sesns/picgo_bed/Snipaste_2023-01-19_22-09-47.png)
![](https://cdn.jsdelivr.net/gh/sesns/picgo_bed/Snipaste_2023-01-19_22-10-21.png)
